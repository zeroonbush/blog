<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文了解this指向 | lhs的个人博客</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="前端开发 lhs的个人博客">
    <link rel="preload" href="/blog/assets/css/0.styles.713b5711.css" as="style"><link rel="preload" href="/blog/assets/js/app.f4463250.js" as="script"><link rel="preload" href="/blog/assets/js/2.e1b088a4.js" as="script"><link rel="preload" href="/blog/assets/js/35.c015d8e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.bf7ca624.js"><link rel="prefetch" href="/blog/assets/js/11.359315dd.js"><link rel="prefetch" href="/blog/assets/js/12.b572844d.js"><link rel="prefetch" href="/blog/assets/js/13.a1769816.js"><link rel="prefetch" href="/blog/assets/js/14.b3355735.js"><link rel="prefetch" href="/blog/assets/js/15.62ee8bc3.js"><link rel="prefetch" href="/blog/assets/js/16.cebfadc0.js"><link rel="prefetch" href="/blog/assets/js/17.f0766b6f.js"><link rel="prefetch" href="/blog/assets/js/18.a0142783.js"><link rel="prefetch" href="/blog/assets/js/19.f2219a1d.js"><link rel="prefetch" href="/blog/assets/js/20.00e0a309.js"><link rel="prefetch" href="/blog/assets/js/21.37f8e443.js"><link rel="prefetch" href="/blog/assets/js/22.e8f2b504.js"><link rel="prefetch" href="/blog/assets/js/23.5251b538.js"><link rel="prefetch" href="/blog/assets/js/24.f84c7b38.js"><link rel="prefetch" href="/blog/assets/js/25.f49ea796.js"><link rel="prefetch" href="/blog/assets/js/26.ef2bd6ca.js"><link rel="prefetch" href="/blog/assets/js/27.e4502fbb.js"><link rel="prefetch" href="/blog/assets/js/28.d3aae567.js"><link rel="prefetch" href="/blog/assets/js/29.671a9226.js"><link rel="prefetch" href="/blog/assets/js/3.4671fbb1.js"><link rel="prefetch" href="/blog/assets/js/30.b213d1f4.js"><link rel="prefetch" href="/blog/assets/js/31.028306e1.js"><link rel="prefetch" href="/blog/assets/js/32.cf4ab366.js"><link rel="prefetch" href="/blog/assets/js/33.67c0451b.js"><link rel="prefetch" href="/blog/assets/js/34.36962303.js"><link rel="prefetch" href="/blog/assets/js/36.0b700b3c.js"><link rel="prefetch" href="/blog/assets/js/37.2882dd92.js"><link rel="prefetch" href="/blog/assets/js/38.8045d9b9.js"><link rel="prefetch" href="/blog/assets/js/39.c74fd6fb.js"><link rel="prefetch" href="/blog/assets/js/4.4d64059e.js"><link rel="prefetch" href="/blog/assets/js/40.73497f0d.js"><link rel="prefetch" href="/blog/assets/js/41.08e6009a.js"><link rel="prefetch" href="/blog/assets/js/42.df44c4c5.js"><link rel="prefetch" href="/blog/assets/js/43.67c62dc2.js"><link rel="prefetch" href="/blog/assets/js/44.40eda2ed.js"><link rel="prefetch" href="/blog/assets/js/45.5ab463e7.js"><link rel="prefetch" href="/blog/assets/js/46.1567d233.js"><link rel="prefetch" href="/blog/assets/js/47.887b8e1a.js"><link rel="prefetch" href="/blog/assets/js/48.53370013.js"><link rel="prefetch" href="/blog/assets/js/49.fcc61acf.js"><link rel="prefetch" href="/blog/assets/js/5.aecc6928.js"><link rel="prefetch" href="/blog/assets/js/50.90e0661f.js"><link rel="prefetch" href="/blog/assets/js/51.9e6f675d.js"><link rel="prefetch" href="/blog/assets/js/52.0d3b6fb3.js"><link rel="prefetch" href="/blog/assets/js/53.108ca534.js"><link rel="prefetch" href="/blog/assets/js/54.3d7e807b.js"><link rel="prefetch" href="/blog/assets/js/55.c290713c.js"><link rel="prefetch" href="/blog/assets/js/56.9f8c206e.js"><link rel="prefetch" href="/blog/assets/js/57.3ab614a9.js"><link rel="prefetch" href="/blog/assets/js/58.0649a37c.js"><link rel="prefetch" href="/blog/assets/js/59.801ce34d.js"><link rel="prefetch" href="/blog/assets/js/6.3236d089.js"><link rel="prefetch" href="/blog/assets/js/60.732c21d6.js"><link rel="prefetch" href="/blog/assets/js/61.cce69ea6.js"><link rel="prefetch" href="/blog/assets/js/62.7c1f93b0.js"><link rel="prefetch" href="/blog/assets/js/7.e428a195.js"><link rel="prefetch" href="/blog/assets/js/8.4140cf02.js"><link rel="prefetch" href="/blog/assets/js/9.8222db1e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.713b5711.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="lhs的个人博客" class="logo"> <span class="site-name can-hide">lhs的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/js_docs/" class="nav-link router-link-active">
  JS
</a></div><div class="nav-item"><a href="/blog/css_docs/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/vue_docs/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/node_docs/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/dart/" class="nav-link">
  Dart
</a></div><div class="nav-item"><a href="/blog/other/" class="nav-link">
  啥都有
</a></div><div class="nav-item"><a href="https://github.com/zeroonbush/blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/js_docs/" class="nav-link router-link-active">
  JS
</a></div><div class="nav-item"><a href="/blog/css_docs/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/blog/vue_docs/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/blog/node_docs/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/blog/dart/" class="nav-link">
  Dart
</a></div><div class="nav-item"><a href="/blog/other/" class="nav-link">
  啥都有
</a></div><div class="nav-item"><a href="https://github.com/zeroonbush/blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/js_docs/" class="sidebar-link">JS简介</a></li><li><a href="/blog/js_docs/JS精度问题.html" class="sidebar-link">JS精度问题</a></li><li><a href="/blog/js_docs/Set数据结构.html" class="sidebar-link">ES6 Set 数据结构</a></li><li><a href="/blog/js_docs/Map数据结构.html" class="sidebar-link">ES6 Map 数据结构</a></li><li><a href="/blog/js_docs/with语法.html" class="sidebar-link">with语法</a></li><li><a href="/blog/js_docs/void 0与undefined的关系.html" class="sidebar-link">void 0与undefined的关系</a></li><li><a href="/blog/js_docs/浅谈基本包装类型.html" class="sidebar-link">浅谈基本包装类型</a></li><li><a href="/blog/js_docs/js中容易忽略的参数.html" class="sidebar-link">js中容易忽略的参数</a></li><li><a href="/blog/js_docs/new的时候干了啥.html" class="sidebar-link">new的时候干了啥</a></li><li><a href="/blog/js_docs/JS调用函数的4种方式.html" class="sidebar-link">JS调用函数的4种方式</a></li><li><a href="/blog/js_docs/一文了解this指向.html" class="active sidebar-link">一文了解this指向</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js_docs/一文了解this指向.html#事件调用环境" class="sidebar-link">事件调用环境</a></li><li class="sidebar-sub-header"><a href="/blog/js_docs/一文了解this指向.html#全局环境" class="sidebar-link">全局环境</a></li><li class="sidebar-sub-header"><a href="/blog/js_docs/一文了解this指向.html#函数环境" class="sidebar-link">函数环境</a></li></ul></li><li><a href="/blog/js_docs/函数防抖和节流.html" class="sidebar-link">函数防抖和节流</a></li><li><a href="/blog/js_docs/EventTarget介绍.html" class="sidebar-link">EventTarget介绍</a></li><li><a href="/blog/js_docs/深拷贝和浅拷贝了解一下.html" class="sidebar-link">来来来,深拷贝和浅拷贝了解一下</a></li><li><a href="/blog/js_docs/原型和原型链.html" class="sidebar-link">原型和原型链</a></li><li><a href="/blog/js_docs/JS生成UUID的多种方式.html" class="sidebar-link">JS生成UUID的多种方式</a></li><li><a href="/blog/js_docs/JSON中的stringify方法.html" class="sidebar-link">JSON.stringify()还能这么玩</a></li><li><a href="/blog/js_docs/一网打尽JS中的循环和遍历.html" class="sidebar-link">一网打尽JS中的循环和遍历</a></li><li><a href="/blog/js_docs/函数的形参和实参.html" class="sidebar-link">函数的形参和实参</a></li><li><a href="/blog/js_docs/使用原生js实现一个回到顶部的功能.html" class="sidebar-link">使用原生js实现一个回到顶部的功能</a></li><li><a href="/blog/js_docs/5分钟回顾原生ajax的几个知识点.html" class="sidebar-link">5分钟回顾原生ajax的几个知识点</a></li><li><a href="/blog/js_docs/10分钟回顾Location对象的几个知识点.html" class="sidebar-link">10分钟回顾Location对象的几个知识点</a></li><li><a href="/blog/js_docs/DOM操作常用API总结.html" class="sidebar-link">DOM操作常用API总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一文了解this指向"><a href="#一文了解this指向" class="header-anchor">#</a> 一文了解this指向</h1> <blockquote><p>this的中文意思是这,在javascript中指的是当前执行代码的环境对象.在非严格模式下,总是指向一个对象,在严格模式下可以是任意值.相信很多同学在看到这个this的时候,肯定是有点脑壳疼的.所以今天我就写了一篇有关this的小文章,来梳理梳理有关this的几种用法,希望对大家都能有所帮助</p></blockquote> <h2 id="事件调用环境"><a href="#事件调用环境" class="header-anchor">#</a> 事件调用环境</h2> <p>谁触发事件,函数里面的<code>this</code>就指向谁</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>btn1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> btn1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#btn1'</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
btn1<span class="token punctuation">.</span>onclick <span class="token operator">=</span> fn
</code></pre></div><p>上面的代码打印出button按钮这个对象</p> <h2 id="全局环境"><a href="#全局环境" class="header-anchor">#</a> 全局环境</h2> <p>首先我们看下在全局环境下this指向谁?</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre></div><p>我们把上面的代码放到浏览器环境下执行,结果是<code>Window</code>对象
再打开终端Terminal,键入<code>node</code>指令,进入node执行环境,结果是global
新建一个<code>index.js</code>文件,使用<code>node index.js</code>运行脚本,这里的<code>this</code>指的是node的默认导出对象,我们执行如下代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token comment">// {}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>exports<span class="token punctuation">)</span>  <span class="token comment">// {}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>exports <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
</code></pre></div><h2 id="函数环境"><a href="#函数环境" class="header-anchor">#</a> 函数环境</h2> <h3 id="单纯函数调用"><a href="#单纯函数调用" class="header-anchor">#</a> 单纯函数调用</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>但是在严格模式下,this指向的就是<code>undefined</code>了</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'use strict'</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// undefined</span>
</code></pre></div><p>可以看出单纯的调用函数时,this指向的就是全局对象</p> <h3 id="对象方法调用"><a href="#对象方法调用" class="header-anchor">#</a> 对象方法调用</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {a: 1, fn: ƒ}</span>
</code></pre></div><p>直接通过<code>对象.方法</code>的形式调用函数的时候,<code>this</code>指向的是调用这个方法的对象,即上面的<code>obj</code>对象
我们稍微改动一下上面的代码,让这个函数在对象中再深入一层,通过<code>对象.属性.方法</code>的形式去调用函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {fn: ƒ}</span>
</code></pre></div><p>可以看到输出的结果是<code>{fn: f}</code>,即<code>b</code>,可以得出结论: <strong>this指向的是最终调用它的对象.当函数被多层对象所包含,且函数被最外层对象调用,<code>this</code>指向的也只是它的上一级对象</strong>
我们再来修改下代码,如下:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> fn2 <span class="token operator">=</span> obj<span class="token punctuation">.</span>fn

<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>可以看出执行结果是<code>Window</code>对象,是不是觉得奇怪,这是为什么呢?
这是因为当我们进行<code>let fn2 = obj.fn</code>这步赋值操作的时候,我们将<code>obj.fn</code>这个函数的内存地址赋值给了<code>fn2</code>这个变量,而<code>obj.fn</code>这个函数干的事情就是<code>console.log(this)</code>,现在我们执行的是<code>fn2()</code>,调用这个<code>fn2</code>函数的是Window对象.那你说,window调用了一个函数,这个函数的任务就是打印出谁调用了它,那答案不是显而易见嘛</p> <p>这次,我们还要来修改下代码,如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  fn<span class="token operator">:</span>fn2
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {a: 1, fn: ƒ}</span>
</code></pre></div><p>要解析这段代码的思路,其实和上面那段代码是一样的.<code>obj</code>调用<code>fn</code>函数,而<code>fn</code>函数指向的是<code>fn2</code>,我们可以理解其实就是<code>obj</code>调用<code>fn2</code>函数,所以执行的结果就是打印出<code>obj</code></p> <p>这次,我们还要来修改下代码,如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>那么,这又是为何呢?我们知道<code>setTimeout</code>是定时器,作用是在一段时间之后执行,<code>setTimeout()</code>这个函数的<code>()</code>中的是它的参数,也就是说<code>function(){console.log(this)}</code>这个函数其实是被当作一个参数传入<code>setTimeout</code>当中的.这个其实有个隐式的操作就是将<code>function(){console.log(this)}</code>赋值给一个假想函数<code>f</code>,到这里的时候,其实已经和<code>obj</code>这个对象无关了.然后等待定时器的时间到了以后,执行的就是<code>f</code>这个函数.这个<code>f</code>是被当作普通函数直接调用的,所以<code>this</code>指向了<code>Window</code>对象.我们再这么一想,<code>function(){console.log(this)}</code>这是个匿名函数啊,它都没有名字,是不能被普通对象调用的,但是<code>Window</code>可以调用啊.
那我们现在要是想要用<code>console.log(this)</code>打印出<code>obj</code>这个对象该怎么办呢?有两个方案:</p> <ul><li>保存this变量</li> <li>箭头函数</li></ul> <p>方法1:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> _self <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 在这里保存好this,免得它到时候跑了</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_self<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {a: 1, fn: ƒ}</span>
</code></pre></div><p>方法2:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {a: 1, fn: ƒ}</span>
</code></pre></div><p>我们使用箭头函数也是可以达到同样的效果的,至于原因我们后面会再提到,这里就先跳过去了
但是<code>setTimeout</code>其实还有一个点容易忽略,我们之前说过在严格模式下直接调用一个函数,它的<code>this</code>指向<code>undefined</code>.但是在<code>setTimeout</code>方法中传入函数的时候,如果这个函数没有指定<code>this</code>的话,它会有自动注入全局上下文,类似于<code>xxx.call(window)</code>这样的操作.看下面代码</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token string">'use strict'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>当然,如果我们在<code>setTimeout</code>中传入函数的时候绑定了<code>this</code>的话,那就不会被注入全局对象</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token string">'use strict'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// {}</span>
</code></pre></div><h3 id="构造函数调用"><a href="#构造函数调用" class="header-anchor">#</a> 构造函数调用</h3> <p>构造函数大家都应该比较熟悉了吧,我们<code>new</code>一下,就new出一个新对象的那种.其实构造函数就是普通的函数,只不过在调用的时候前面加了<code>new</code>运算符.关于<code>new</code>运算符是干嘛的,可以看我的另外一篇文章:<a href="https://juejin.im/post/5ed9f8f8e51d45789b35b01c?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">JS new的时候干了啥<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Person {}</span>
</code></pre></div><p>当我们使用构造函数调用的时候,<code>this</code>指向了这个实例化出来的对象,我们将上面的代码和下面的代码进行一个比对就能看出不同了</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>两段代码的唯一区别就是后面的代码没有<code>new</code>它,从而指向了<code>Window</code>对象.由此可见,使用了<code>new</code>之后,这个构造函数的<code>this</code>被绑定到了正在构造的新对象上.这个在 <a href="https://juejin.im/post/5ed9f8f8e51d45789b35b01c?utm_source=gold_browser_extension" target="_blank" rel="noopener noreferrer">JS new的时候干了啥<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 也是有讲到的,不太清楚的童鞋可以跳过去看一看
我们再来一个例子巩固下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment">// Window</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p <span class="token operator">===</span> window<span class="token punctuation">)</span>  <span class="token comment">// true</span>
</code></pre></div><p>不使用<code>new</code>关键字,<code>Person</code>普通函数返回<code>this</code>,函数又是被<code>Window</code>调用的,所以就是返回<code>Window</code>对象,那么<code>p === window</code>返回的结果自然就是<code>true</code>了
但是在构造函数中,如果显式的返回了一个新的对象(非<code>null</code>),那么<code>this</code>就会指向那个对象</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span><span class="token string">'lisi'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'zhangsan'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment">// lisi</span>
</code></pre></div><h3 id="call-apply-bind-三兄弟"><a href="#call-apply-bind-三兄弟" class="header-anchor">#</a> call,apply,bind 三兄弟</h3> <p>这三兄弟都是<code>Function</code>这个对象原型上的方法.它们可以更改函数中的<code>this</code>指向.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>  <span class="token comment">// {}</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>  <span class="token comment">// {}</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {}</span>
</code></pre></div><p>这里可以看出它们三兄弟确实都可以改变<code>this</code>的指向,那么它们的区别在哪里呢?
<code>call</code>和<code>apply</code>的作用基本一致,区别在于传参的方式不太一样</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
</code></pre></div><p><code>call</code>的参数是一个个传进去的,<code>apply</code>的参数是直接传了一个数组进去
那么<code>call</code>和<code>bind</code>又有什么区别呢?</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>
</code></pre></div><p>可以看出来,绑定<code>bind</code>的时候是不会直接调用函数的,它会返回一个新的函数,我们需要主动去<code>()</code>一下,它才会执行.相对比之下,<code>call</code>和<code>apply</code>都是会立即执行函数的.从第二个参数开始传入的都是执行函数时需要传入的参数,<code>call</code>和<code>bind</code>传参的格式一致.另外,在构造函数调用的时候,内部其实也是有通过<code>call</code>来变更<code>this</code>指向的.这个前面我们也说到了,指向了创建出来的对象.
使用<code>bind</code>方法创建的上下文为永久性的上下文环境,没法更改,<code>call</code>和<code>apply</code>也不行.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 0</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// undefined  # 通过call改变了this</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 1  # 通过bind改变了this</span>
<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// 1  # 通过bind改变了this, call再想要来更改就没门了</span>
</code></pre></div><p>上面代码中,我们是给一个普通函数指定<code>this</code>,下面我们来看看为对象中的方法指定<code>this</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// {}</span>
</code></pre></div><p>换成构造函数,再来看看</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// Person.call is not a constructor</span>
</code></pre></div><p>错误提示是Person.call不是一个构造函数,这是因为此时我们去<code>new</code>的是<code>Person.call</code>而不是<code>Person</code>,这当然不是一个构造函数了.我们换<code>bind</code>再来试一试,看看结果</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Person {}</span>
</code></pre></div><p>发现结果是<code>Person {}</code>,这说明我们的绑定没有成功,否则结果就应该是<code>{a:1}</code>了.因此,我们也可以得到结论,在构造函数中,我们去<code>new</code>的时候,<code>bind</code>绑定的<code>this</code>是不会起效果的</p> <h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>箭头函数是在ES6的时候才有的,它的语法比普通的函数表达式要简洁,并且没有自己的<code>this</code>和<code>arguments</code>.它并不创建自身的上下文,其上下文在定义的时候就已经确定了,即一次绑定,便不可更改.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//Window</span>
</code></pre></div><p>这里为啥是<code>Window</code>而不是<code>obj</code>呢,箭头函数的<code>this</code>在定义的时候就已经确定了.在箭头函数中引用<code>this</code>,实际上调用的是定义时的上一层作用域的<code>this</code>.那么上面的代码中调用的就是<code>Window</code>对象了,因为<code>obj</code>对象是不能形成作用域的.
我们再来看下面的代码,结果也是<code>Window</code>,因为即使<code>fn</code>在函数中的位置深了一层,但是仍然没有形成作用域,箭头函数定义的时候还是指向全局对象了</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//Window</span>
</code></pre></div><p>我们先看如下代码:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// Window</span>
</code></pre></div><p>这里函数作为对象的一个方法使用,里面有个闭包.当我们通过<code>对象.方法</code>去调用的时候,实际上就相当于是函数直接调用.此时的<code>this</code>指向<code>Window</code>
我们改动代码如下,将闭包的形式变成箭头函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// {fn: ƒ}</span>
</code></pre></div><p>此时的输出结果变成<code>obj</code>这个对象了.因为箭头函数在定义的时候是在<code>fn</code>这个函数中,所以箭头函数中的<code>this</code>指向了<code>fn</code>的<code>this</code>,也就是<code>obj</code>.大家是否还记得前面有个地方我们留了一个悬念给大家.对了,就是定时器那里.我们说过,使用箭头函数也可以达到同样的效果,现在童鞋们是否都明白了.箭头函数的<code>this</code>在定义的时候就已经确定了,<code>call</code>,<code>apply</code>,<code>bind</code>等都无法改变它.</p> <p>由于箭头函数的外部决定了上下文以及静态上下文等特性,因此最好不要在全局环境下使用箭头函数来定义方法,我们建议使用函数表达式来定义函数,可确保正确的上下文环境</p> <blockquote><p><strong>总结:</strong>  有关<code>this</code>的学习到这里基本就结束了.有时间的同学建议将我文章中的代码都敲一遍,加深对<code>this</code>的理解,达到事半功倍的效果</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/js_docs/JS调用函数的4种方式.html" class="prev">
        JS调用函数的4种方式
      </a></span> <span class="next"><a href="/blog/js_docs/函数防抖和节流.html">
        函数防抖和节流
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.f4463250.js" defer></script><script src="/blog/assets/js/2.e1b088a4.js" defer></script><script src="/blog/assets/js/35.c015d8e7.js" defer></script>
  </body>
</html>
